package br.com.castgroup.cursos.service;

import java.beans.Beans;
import java.time.LocalDate;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;

import javax.transaction.Transactional;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import br.com.castgroup.cursos.entities.Categoria;
import br.com.castgroup.cursos.entities.Curso;
import br.com.castgroup.cursos.entities.Log;
import br.com.castgroup.cursos.entities.Usuario;
import br.com.castgroup.cursos.repository.CategoriaRepository;
import br.com.castgroup.cursos.repository.CursoRepository;
import br.com.castgroup.cursos.repository.LogRepository;
import br.com.castgroup.cursos.repository.UsuarioRepository;

@Service
public class CursoService {

	@Autowired
	UsuarioRepository usuarioRepository;

	@Autowired
	LogRepository logRepository;

	@Autowired
	CursoRepository cursoRepository;

	@Autowired
	CategoriaRepository categoriaRepository;

	Usuario usuarioLogado = new Usuario();

	public void usuarioLogado(Usuario usuario) {
		usuarioLogado = usuario;
	}

	@Transactional
	public void cadastrarCurso(Curso curso) {
		validaData(curso);
		existeCategoria(curso, categoriaRepository);
		existeDescricao(curso, cursoRepository);
		finalizado(curso);
		System.out.println("Usuario ao cadastrar: " + usuarioLogado + curso);
		@SuppressWarnings("deprecation")
		Log log = new Log(null, LocalDate.now(), LocalDate.now(), curso, "Cadastrou Curso",
				usuarioRepository.getOne(usuarioLogado.getIdUsuario()));
		curso.setInclusao(LocalDate.now());
		logRepository.save(log);
		cursoRepository.save(curso);
	}

	@Transactional
	public void atualizarCurso(Curso request, Integer id_curso) {
		Optional<Curso> item = cursoRepository.findById(id_curso);
		if (item.isEmpty()) {
			throw new RuntimeException("Curso não encontrado");
		} else {
			Curso curso = item.get();
			validaDataUpdate(request);
			converter(request, curso);
			finalizado(curso);
		
			existeCategoria(curso, categoriaRepository);

			@SuppressWarnings("deprecation")
			Log log = new Log(null, item.get().getInclusao(), LocalDate.now(), curso, "Atualizou Curso",
					usuarioRepository.getOne(usuarioLogado.getIdUsuario()));
			logRepository.save(log);
			cursoRepository.save(curso);
		}
	}

	@Transactional
	public void deletarCursoPorId(Integer id_curso) {
		Optional<Curso> item = cursoRepository.findById(id_curso);
		if (item.isEmpty()) {
			throw new RuntimeException("Curso não encontrado");
		} else {
			Curso curso = item.get();
			if (curso.getFinalizado()) {
				throw new RuntimeException("Curso finalizado não pode ser excluido");
			}
			@SuppressWarnings("deprecation")
			Log log = new Log(null, curso.getInclusao(), LocalDate.now(), curso, "Deletou Curso",
					usuarioRepository.getOne(usuarioLogado.getIdUsuario()));
			logRepository.save(log);
			cursoRepository.delete(curso);
		}
	}

	public List<Curso> acharTodos() {
		return cursoRepository.findAll();

	}

	private void existeDescricao(Curso curso, CursoRepository cursoRepository) {
		List<Curso> findByDescricao = cursoRepository.findByDescricao(curso.getDescricao());
		if (findByDescricao.size() > 0) {
			throw new RuntimeException("Curso já cadastrado");
		}

	}

	private void existeCategoria(Curso request, CategoriaRepository categoriaRepository) {
		Optional<Categoria> categoria = categoriaRepository.findById(request.getCategoria().getId_categoria());
		if (categoria.isEmpty()) {
			throw new RuntimeException("Não existe a categoria informada");
		}
	}

	private void validaData(Curso request) {
//		if (request.getInicio().isBefore(LocalDate.now())) {
//			throw new RuntimeException("Data de inicio anterior a data atual");
//		}
		if (request.getInicio().isAfter(request.getTermino())) {
			throw new RuntimeException("Data de início após data de término");
		}
		if (cursoRepository.contador(request.getInicio(), request.getTermino()) > 0) {
			throw new RuntimeException("Já existe curso ocupando essa data");
		}
	}

//	private void validaDataUpdate(Curso request) {
//		if (request.getInicio().isAfter(request.getTermino())) {
//			throw new RuntimeException("Data de início após data de término");
//		}
//		if (cursoRepository.contador(request.getInicio(), request.getTermino()) > 1) {
//			throw new RuntimeException("Já existe curso ocupando essa data");
//		}
//	}

	private void validaDataUpdate(Curso request) {
		if (request.getInicio().isAfter(request.getTermino())) {
			throw new RuntimeException("Data de início após data de término");
		}
		if ((cursoRepository.contador(request.getInicio(), request.getTermino()) == 1)) {
			Curso curso1 = new Curso();
			List<Curso> cursosPorData = cursoRepository.cursosPorData(request.getInicio(), request.getTermino());
	
			for (Curso curso : cursosPorData) {
				System.out.println(curso.getDescricao());
				if (curso.getId_curso() == request.getId_curso()) {
					BeanUtils.copyProperties(curso, curso1);
				}
				if (curso1.getId_curso().equals(curso.getId_curso())){
					System.out.println("OI");			
				}
			}
					
		}
		

		
	}

	public void converter(Curso request, Curso curso) {
		curso.setId_curso(request.getId_curso());
		curso.setCategoria(request.getCategoria());
		curso.setDescricao(request.getDescricao());
		curso.setFinalizado(request.getFinalizado());
		curso.setInicio(request.getInicio());
		curso.setTermino(request.getTermino());
		curso.setQuantidadeAlunos(request.getQuantidadeAlunos());
	}

	public void finalizado(Curso curso) {
		if (curso.getTermino().isBefore(LocalDate.now())) {
			curso.setFinalizado(true);
		} else {
			curso.setFinalizado(false);
		}
	}

//	public List<Curso> listarPorData(LocalDate inicio, LocalDate termino) {
//		 cursoRepository.findByTerminoBetween(inicio, termino);
//		 cursoRepository.findByInicioBetween(inicio, termino);
//		 List<Curso> cursos = new ArrayList<>();
//		 cursos.addAll(cursoRepository.findByTerminoBetween(inicio, termino));
//		 cursos.addAll(cursoRepository.findByInicioBetween(inicio, termino));
//		 return cursos;
//	}

	public List<Curso> listarPorData(LocalDate inicio, LocalDate termino) {
		return cursoRepository.cursosPorData(inicio, termino);
	}

	public Optional<Curso> acharPorId(Integer id_curso) {
		Optional<Curso> item = cursoRepository.findById(id_curso);
		if (item.isEmpty()) {
			throw new RuntimeException("Curso não encontrado");
		}
		return item;
	}

	public List<Curso> acharPorDescricao(String descricao) {
		List<Curso> listaDeCursos = cursoRepository.findByDescricao(descricao);
		if (listaDeCursos.isEmpty()) {
			throw new RuntimeException("Não foi encotrado nenhum curso com esse nome");
		}
		return listaDeCursos;

	}

}
